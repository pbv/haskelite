<!doctype html>
<html>
  <head>
    <link rel="stylesheet" href="screen.css">
  </head>

  <body>
    <h1>Language</h1>

<h2>Expressions</h2>

Integers, characters, strings (i.e. lists of characters),
variables, arithmetic operations (`+, -, *, div, mod`),
comparisons (`==`, `<=`, etc.), tuples, lists, enumerations
(e.g. `[1..10]`), lambda-expressions, let bindings, case expressions.

<h2>Function definitions</h2>

Pattern matching over integers, characters, lists and tuples; boolean
guards; recursive definitions.


<h2>Standard Prelude</h2>

Definitions for the following functions from the Standard Prelude are
provided.  Note that functions based on equality or orderning have an
overly polymorphic type (they should really have a typeclass
restriction) and thus can "get stuck" at runtime.

<pre>
even, odd :: Int -> Bool
max, min :: a -> a -> a        -- NB: too polymorphic!
fst :: (a,b) -> a
snd :: (a,b) -> b
(&&), (||) :: Bool -> Bool
head :: [a] -> a
tail :: [a] -> [a]
(++) :: [a] -> [a] -> [a]
length :: [a] -> Int
reverse :: [a] -> [a]
init :: [a] -> [a]
last :: [a] -> a  
sum, product :: [Int] -> Int
take, drop :: Int -> [a] -> [a]
maximum, minimum :: [a] -> a   -- NB: too polymorphic!
concat :: [[a]] -> [a]
repeat :: a -> [a]
cycle :: [a] -> [a]
iterate :: (a -> a) -> a -> [a]
map :: (a -> b) -> [a] -> [b]
filter :: (a -> Bool) -> [a] -> [a]
foldr :: (a -> b -> b) -> b -> [a] -> b
foldl :: (a -> b -> a) -> a -> [b] -> a
foldl' :: (a -> b -> a) -> a -> [b] -> a
zip :: [a] -> [b] -> [(a,b)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
takeWhile, dropWhile :: (a -> Bool) -> [a] -> [a]
any, all :: (a -> Bool) -> [a] -> Bool
</pre>

<h2>Not implemented</h2>

The following Haskell 98 features are <em>not</em> implemented:

<ul>
<li>modules
<li>type classes
<li>the numeric tower (Float, Integer, Double, etc.)
<li>list compreensions
<li>user-defined algebraic data types
</ul>

<hr>
Pedro Vasconcelos, 2023
