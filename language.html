<!doctype html>
<html>
  <head>
    <link rel="stylesheet" href="screen.css">
  </head>

  <body>
    <h1>Haskelite language</h1>

    <p> This page describes the subset of Haskell accepted by the Haskelite interpreter.</p>
										  

<h2>Expressions</h2>

<p>Integers, characters, strings (i.e. lists of characters),
variables, arithmetic operations (+, -, *, div, mod),
comparisons (==, <=, etc.), tuples, lists, enumerations
(e.g. [1..10]), lambda-expressions, let bindings, case expressions.</p>


<h2>Data type definitions</h2>
<p> Haskell-98 like <code>data</code> declarations; no existentials or GADTs;
 no <code>deriving</code> (because there are no typeclasses)!</p>

<p>Currently all data declarations must come <em>before</em> any function
 definitions.</p>

<h2>Function definitions</h2>

<p>Pattern matching over integers, characters, lists and tuples; boolean
guards; recursive definitions.</p>

<h2>Standard Prelude</h2>

Definitions for the following functions from the Standard Prelude are
provided.  Note that functions based on equality or ordering have an
overly polymorphic type (they should really have a typeclass
restriction); they will fail at runtime if you apply
them to function values.

<pre>
even, odd :: Int -> Bool
max, min :: a -> a -> a        -- NB: these are too polymorphic
compare :: a -> a -> Ordering  -- and may fail at runtime!
fst :: (a,b) -> a
snd :: (a,b) -> b
(&&), (||) :: Bool -> Bool
head :: [a] -> a
tail :: [a] -> [a]
(++) :: [a] -> [a] -> [a]
length :: [a] -> Int
reverse :: [a] -> [a]          -- NB: defined as naive reverse 
init :: [a] -> [a]
last :: [a] -> a  
sum, product :: [Int] -> Int
take, drop :: Int -> [a] -> [a]
maximum, minimum :: [a] -> a   -- NB: too polymorphic!
concat :: [[a]] -> [a]
repeat :: a -> [a]
cycle :: [a] -> [a]
iterate :: (a -> a) -> a -> [a]
map :: (a -> b) -> [a] -> [b]
filter :: (a -> Bool) -> [a] -> [a]
foldr :: (a -> b -> b) -> b -> [a] -> b
foldl :: (a -> b -> a) -> a -> [b] -> a
foldl' :: (a -> b -> a) -> a -> [b] -> a
zip :: [a] -> [b] -> [(a,b)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
takeWhile, dropWhile :: (a -> Bool) -> [a] -> [a]
any, all :: (a -> Bool) -> [a] -> Bool
chr :: Int -> Char
ord :: Char -> Int
isAlpha, isDigit, isAlphaNum, isUpper, isLower :: Char -> Bool    
</pre>

<h2>Not implemented</h2>

The following Haskell 98 features are <em>not</em> implemented:

<ul>
<li>where clauses
<li>modules
<li>type classes
<li>the numeric tower (Float, Integer, Double, etc.)
<li>list compreensions
</ul>

<hr>
Pedro Vasconcelos, 2023
